CREATE VIEW gold.report_product as 

WITH base_query as(
		select 
			sl.order_number,
			sl.order_date,
			sl.customer_key,
			sl.quantity,
			sl.product_key,
			sl.sales_amount,
			pr.product_number,
			pr.product_name,
			pr.category,
			pr.subcategory,
			pr.cost
		from gold.fact_sales sl
		left join gold.dim_products pr
		on sl.product_key= pr.product_key
		WHERE order_date IS NOT NULL 
		)
, aggregation as (
select	
	product_key,
	product_name,
	product_number,
	category,
	subcategory,
	cost,
	COUNT(distinct order_number) as total_order ,
	COUNT(distinct customer_key) as total_customer,
	SUM(sales_amount) as total_sales,
	SUM(quantity) as total_quantity ,
	MAX(order_date) as last_order,
	DATEDIFF ( month, MIN(order_date) ,MAX(order_date)) as lifespan,
	ROUND(AVG ( CAST( sales_amount as FLOAT ) / NULLIF (quantity ,0)) , 2) as avg_selling_price
from base_query
group by  product_key,
	product_name,
	product_number,
	category,
	subcategory,
	cost
	)
select 
	product_key,
	product_name,
	product_number,
	category,
	subcategory,
	cost,
	avg_selling_price,
	total_order ,
	total_sales,
	CASE WHEN total_sales > 50000 THEN 'High Perfomer'
		WHEN  total_sales > = 10000 THEN 'Mid-range'
		ELSE 'Low-perfomers'
		END AS product_segment,
	total_quantity ,
	last_order,
	DATEDIFF(month ,last_order,getdate()) as  recency,
	lifespan,
	CASE WHEN total_order =0 THEN 0
	ELSE total_sales/total_order
	END as avg_order_renue,
	CASE WHEN lifespan=0 THEN total_sales
		ELSE total_sales/lifespan
		END AS AVG_monthly_revenue

from aggregation ;
